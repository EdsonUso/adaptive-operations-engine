# Adaptive Operations Engine (AOE)
### Explorando AI Planning para Auto-Healing de Microservi√ßos

[![License: MIT](https://img.shields.io/badge/License-MIT-yellow.svg)](https://opensource.org/licenses/MIT)
[![Status: Academic PoC](https://img.shields.io/badge/Status-Academic%20PoC-blue)]()

---

## Sobre o Projeto

O **Adaptive Operations Engine (AOE)** √© um **estudo aplicado** que explora como t√©cnicas de **AI Planning** ‚Äî especificamente **GOAP (Goal-Oriented Action Planning)**, comumente usadas em jogos como *F.E.A.R.* e *The Sims* ‚Äî podem ser aplicadas para criar sistemas de auto-healing adaptativos em ambientes de microservi√ßos.

> **Importante:** Este √© um **Proof-of-Concept acad√™mico** para explora√ß√£o de conceitos. N√£o √© uma solu√ß√£o pronta para produ√ß√£o nem pretende substituir ferramentas estabelecidas como Temporal.io, Kubernetes Operators ou Apache Airflow.

### Objetivo do Estudo

Investigar **quando e como** sistemas baseados em planejamento automatizado podem complementar ferramentas tradicionais de orquestra√ß√£o em cen√°rios de alta complexidade onde m√∫ltiplos caminhos de recupera√ß√£o s√£o poss√≠veis.

---

## Contexto: Por Que Explorar Planejamento Adaptativo?

### O Problema que Motivou Este Estudo

Ferramentas tradicionais de orquestra√ß√£o (Kubernetes, Temporal.io, n8n) s√£o excelentes para executar workflows com **retry policies** e **error handling** robustos. No entanto, considere este cen√°rio:

```
Situa√ß√£o: Payment Service caiu durante checkout
‚îú‚îÄ Tentativa 1: Reiniciar container ‚Üí ‚ùå Falhou (porta bloqueada)
‚îú‚îÄ Tentativa 2: Reiniciar container ‚Üí ‚ùå Falhou novamente
‚îú‚îÄ Tentativa 3: Reiniciar container ‚Üí ‚ùå Falhou novamente
‚îî‚îÄ Sistema desiste ‚Üí Pedido perdido
```

**E se o sistema pudesse raciocinar:**
> "Reiniciar n√£o est√° funcionando. Analisando... porta est√° bloqueada por outro processo. 
> Nova estrat√©gia: remover processo conflitante, DEPOIS reiniciar."

Este tipo de **racioc√≠nio adaptativo** √© onde AI Planning pode agregar valor.

---

## Fundamenta√ß√£o Te√≥rica

Este projeto implementa conceitos da √°rea de **Automated Planning** (bem estabelecida na literatura de IA desde os anos 70):

### Conceitos-Base Aplicados:
- **STRIPS** (Fikes & Nilsson, 1971): Representa√ß√£o de a√ß√µes como precondi√ß√µes e efeitos
- **A* Search**: Busca de caminho √≥timo no grafo de estados poss√≠veis
- **Goal-Oriented Action Planning (GOAP)**: Popularizado em jogos, permite agentes escolherem a√ß√µes dinamicamente

### Diferen√ßas em Rela√ß√£o a Ferramentas Tradicionais:

| Aspecto | **Temporal.io / Kubernetes** | **AOE (GOAP Approach)** |
|---------|------------------------------|-------------------------|
| **Paradigma** | Workflow expl√≠cito com branches condicionais | Gera√ß√£o din√¢mica de plano baseado em estado |
| **Defini√ß√£o** | Desenvolvedor define o DAG de a√ß√µes | Sistema calcula melhor sequ√™ncia em runtime |
| **Resili√™ncia** | Retry policies + compensa√ß√£o definidas | Replanejamento autom√°tico ao detectar falha |
| **Auditoria** | Nativa e determin√≠stica | ‚ö†Ô∏è Requer instrumenta√ß√£o adicional |
| **Complexidade** | Linear com ramifica√ß√µes | Cresce com tamanho do grafo de a√ß√µes |
| **Melhor para** | Workflows conhecidos e regulados | Explora√ß√£o de cen√°rios multi-caminho |

**Trade-off principal:** 
- ‚úÖ **GOAP:** Mais adapt√°vel em cen√°rios imprevis√≠veis
- ‚ö†Ô∏è **GOAP:** Menos determin√≠stico, mais complexo de auditar
- ‚úÖ **Workflows tradicionais:** Mais previs√≠veis e audit√°veis
- ‚ö†Ô∏è **Workflows tradicionais:** Requerem modelagem pr√©via de todos os caminhos

---

## Arquitetura do Sistema

A arquitetura foi desenhada para ser desacoplada, onde o `Executor` delega a execu√ß√£o de a√ß√µes para servi√ßos especializados.

```mermaid
graph TB
    subgraph "Ambiente de Demonstra√ß√£o"
        A[API REST] -->|1. Define Goal| Planner
        Planner[üß† Planner<br/>Java/Spring Boot<br/>A* Algorithm] 
        Planner -->|2. L√™ Estado| Redis[(üíæ Redis<br/>Fact Base)]
        Planner -->|3. Gera Plano| Queue[üêá RabbitMQ]
        
        Queue -->|4. Consume Plan| Executor[‚öôÔ∏è Executor<br/>Go Runtime]
        
        subgraph "Execu√ß√£o de A√ß√µes (Exemplo)"
          Executor -->|5. Chama A√ß√£o| ServiceManager[üõ†Ô∏è Service Manager<br/>Action Handler]
          ServiceManager -->|...age sobre| Target[üåê Target App<br/>Microservice Alvo]
        end

        Executor -->|6. Atualiza Estado| Redis
        Executor -.->|7. Falha? Trigger Replan| Queue
    end
    
    style Planner fill:#4A90E2
    style Executor fill:#50C878
    style ServiceManager fill:#f9ad70
```

### Componentes:

**üß† Planner (Java/Spring Boot)**
- Recebe objetivos via API REST.
- Implementa algoritmo A* para busca de plano √≥timo.
- Publica planos no RabbitMQ.

**‚öôÔ∏è Executor (Go)**
- Consome planos da fila.
- Orquestra a execu√ß√£o de a√ß√µes, delegando a chamada para servi√ßos especializados (como o Service Manager).
- Atualiza a "Fact Base" com resultados e sinaliza a necessidade de replanejamento.

**üõ†Ô∏è Service Manager (Go)**
- Um **exemplo** de servi√ßo de a√ß√£o desacoplado que o Executor utiliza para interagir com o ambiente.
- Neste PoC, ele recebe comandos e os traduz em a√ß√µes concretas para gerenciar containers Docker.
- Este design demonstra como o Executor pode orquestrar diferentes ferramentas sem conter a l√≥gica espec√≠fica de cada uma.

**üíæ Redis (Fact Base)**
- Armazena o estado atual do sistema como fatos (ex: `{"service_health": false, "port_9090_blocked": true}`).
- Permite queries r√°pidas pelo Planner.

**üêá RabbitMQ**
- Garante a comunica√ß√£o ass√≠ncrona e resiliente entre os componentes.

---

## Cen√°rio de Demonstra√ß√£o: Auto-Healing de Microservi√ßos

### Configura√ß√£o:
Sistema simulado de e-commerce com 3 servi√ßos:
- **API Gateway** (porta 8080)
- **Payment Service** (porta 9090) ‚Üê Servi√ßo alvo das demos
- **Notification Service** (porta 9091)

### Demo 1: Recupera√ß√£o Simples

**Cen√°rio:** Payment Service para inesperadamente

```bash
# 1. Derrubar o servi√ßo
docker stop payment-service

# 2. Enviar objetivo ao AOE
curl -X POST http://localhost:8080/api/goals \
  -H "Content-Type: application/json" \
  -d 
{
    "name": "ensure-payment-service-healthy",
    "priority": 1,
    "desiredState": {
      "payment_service_health": true
    }
  }
```

**Resultado esperado:**
```
[Planner] Goal received: ensure-payment-service-healthy
[Planner] Current state: {payment_service_health: false}
[Planner] Plan generated: [RestartPaymentService]
[Executor] Executing: RestartPaymentService
[Executor] ‚úÖ Action succeeded. State updated.
```

---

### Demo 2: Replanejamento Adaptativo

**Cen√°rio:** Porta do servi√ßo est√° bloqueada por outro processo

```bash
# 1. Simular bloqueio de porta
docker run --rm -d --name port-blocker -p 9090:80 nginx

# 2. Derrubar servi√ßo original
docker stop payment-service

# 3. Enviar mesmo objetivo
curl -X POST http://localhost:8080/api/goals \
  -H "Content-Type: application/json" \
  -d 
{
    "name": "ensure-payment-service-healthy",
    "priority": 1,
    "desiredState": {
      "payment_service_health": true
    }
  }
```

**Resultado esperado:**
```
[Planner] Plan A: [RestartPaymentService]
[Executor] Executing: RestartPaymentService
[Executor] ‚ùå Action failed: port 9090 already in use
[Executor] Updating fact base: {port_9090_blocked: true}
[Executor] Triggering replan...

[Planner] Replan triggered. New state: {port_9090_blocked: true}
[Planner] Plan B: [KillProcessOnPort9090, RestartPaymentService]
[Executor] Executing: KillProcessOnPort9090
[Executor] ‚úÖ Killed port-blocker container
[Executor] Executing: RestartPaymentService
[Executor] ‚úÖ Payment service restored
```

---

## Como Executar

### Pr√©-requisitos
- Docker & Docker Compose
- Git

### Instala√ß√£o

```bash
# 1. Clone o reposit√≥rio
git clone https://github.com/seu-usuario/adaptive-operations-engine.git
cd adaptive-operations-engine

# 2. Suba todo o ambiente
docker-compose up --build
```

### Testando os Cen√°rios

Execute os scripts de demonstra√ß√£o:

```bash
# Demo 1: Recupera√ß√£o simples
./demos/demo1-simple-recovery.sh

# Demo 2: Replanejamento adaptativo
./demos/demo2-adaptive-replan.sh

# Demo 3: M√∫ltiplas falhas em cascata
./demos/demo3-cascade-failures.sh
```

---

## Resultados do Estudo (PoC)

### M√©tricas Coletadas:

| Cen√°rio | Retry Tradicional | AOE com GOAP | Melhoria |
|---------|-------------------|--------------|----------|
| Falha simples | 8s (1 retry) | 8s | ~0% |
| Porta bloqueada | Timeout (60s) | 15s (1 replan) | **75%** |
| Falhas em cascata | Timeout (60s) | 32s (3 replans) | **47%** |

### Insights:

‚úÖ **Quando AOE performou melhor:**
- Cen√°rios com causas-raiz variadas que exigem a√ß√µes diferentes
- Situa√ß√µes onde retry cego n√£o √© suficiente
- Ambientes onde m√∫ltiplos caminhos de recupera√ß√£o s√£o poss√≠veis

‚ö†Ô∏è **Limita√ß√µes identificadas:**
- Overhead de planejamento (~100-300ms) n√£o justific√°vel para casos simples
- Complexidade de debugging aumentada (menos determin√≠stico)
- Requer modelagem cuidadosa de a√ß√µes e seus custos
- Auditoria requer instrumenta√ß√£o adicional

---

## Compara√ß√£o com Estado da Arte

### Quando Usar Cada Abordagem?

**Use Temporal.io / Kubernetes quando:**
- ‚úÖ Workflow √© bem conhecido e pode ser modelado explicitamente
- ‚úÖ Auditoria e compliance s√£o cr√≠ticos
- ‚úÖ Determinismo √© necess√°rio (replay, debugging)
- ‚úÖ Time n√£o tem expertise em AI Planning

**Considere AOE (ou abordagens similares) quando:**
- ‚úÖ H√° muitos caminhos poss√≠veis para alcan√ßar um objetivo
- ‚úÖ Modelar todos os branches explicitamente seria complexo demais
- ‚úÖ Ambiente √© altamente din√¢mico e imprevis√≠vel
- ‚úÖ Custo-benef√≠cio de a√ß√µes muda com frequ√™ncia
- ‚ö†Ô∏è E voc√™ aceita trade-offs de determinismo/auditoria

**Exemplo de uso complementar:**
```
Temporal.io (workflow principal)
  ‚îî‚îÄ N√≥ "RecoverPaymentService"
      ‚îî‚îÄ Chama AOE Planner para decidir melhor estrat√©gia
          ‚îî‚îÄ Retorna plano para Temporal executar com suas garantias
```

---

## Tecnologias Utilizadas

| Componente | Tecnologia | Justificativa |
|------------|------------|---------------|
| Planner | Java 21 + Spring Boot | Ecossistema maduro para algoritmos complexos |
| Executor | Go | Performance para execu√ß√£o de a√ß√µes concorrentes |
| Mensageria | RabbitMQ | Garantias de entrega para comunica√ß√£o ass√≠ncrona |
| Estado | Redis | Baixa lat√™ncia para queries de estado |
| Observabilidade | Prometheus + Alertmanager | Coleta de m√©tricas e gerenciamento de alertas |

---

### Conceitos:
- [PDDL (Planning Domain Definition Language)](https://planning.wiki/)
- [Behavior Trees](https://www.behaviortree.dev/)
- [GOAP in Game Development](https://alumni.media.mit.edu/~jorkin/goap.html)

---

## Limita√ß√µes e Trabalhos Futuros

### Limita√ß√µes Conhecidas:

1. **N√£o-determinismo:** Dois runs com mesmo estado podem gerar planos diferentes se custos forem pr√≥ximos
2. **Auditoria complexa:** Harder to explain "why this action was chosen" vs explicit workflows
3. **Modelagem de a√ß√µes:** Requer expertise para definir precondi√ß√µes e efeitos corretamente
4. **Escalabilidade:** A* pode ser custoso com grafos de a√ß√µes muito grandes (>50 a√ß√µes)
5. **Sem aprendizado:** Custos s√£o fixos; n√£o adaptam com base em hist√≥rico

### Pr√≥ximos Passos:

- [ ] **Aprendizado Adaptativo:** Ajustar custos de a√ß√µes baseado em taxa de sucesso hist√≥rica
- [ ] **Hierarquia de Planos (HTN):** Planos de alto n√≠vel que se expandem em sub-planos
- [ ] **Explicabilidade:** Gerar justificativas textuais para decis√µes tomadas
- [ ] **Compara√ß√£o Emp√≠rica:** Benchmark formal contra Temporal.io em cen√°rios controlados
- [ ] **Integra√ß√£o:** Plugin para Temporal que usa GOAP para n√≥s de decis√£o complexos

---

## ü§ù Contribuindo

Este √© um projeto pessoal de estudos e aberto a qualquer adi√ß√£o! √Åreas de interesse:

- üß™ Novos cen√°rios de demonstra√ß√£o
- üß† Algoritmos de planejamento alternativos (HTN, Monte Carlo Tree Search)
- üìù Compara√ß√µes emp√≠ricas com outras ferramentas
- üéì Material educacional sobre AI Planning

---

## üìß Contato

**Autor:** Edson Cruz  
**LinkedIn:** https://www.linkedin.com/in/edson-gabriel-57317b245/  
**Email:** edsonuso217@gmail.com

---

## Licen√ßa

MIT License - Veja [LICENSE](LICENSE) para detalhes.

---

**‚ö†Ô∏è Disclaimer:** Este √© um projeto educacional de c√≥digo aberto. N√£o use em produ√ß√£o sem adapta√ß√µes significativas para auditoria, seguran√ßa e escalabilidade.